<body bgcolor=black>
<center>
<canvas id='canvas1' width=800 height=800></canvas>

<script>

// INITIALIZE GPU PROGRAM

let start_gl = (canvas, meshData, vertexSize, vertexShader, fragmentShader) => {
   let gl = canvas.getContext("webgl");
   let program = gl.createProgram();
   gl.program = program;
   let addshader = (type, src) => {
      let shader = gl.createShader(type);
      gl.shaderSource(shader, src);
      gl.compileShader(shader);
      if (! gl.getShaderParameter(shader, gl.COMPILE_STATUS))
         throw "Cannot compile shader:\n\n" + gl.getShaderInfoLog(shader);
      gl.attachShader(program, shader);
   };
   addshader(gl.VERTEX_SHADER  , vertexShader  );
   addshader(gl.FRAGMENT_SHADER, fragmentShader);
   gl.linkProgram(program);
   if (! gl.getProgramParameter(program, gl.LINK_STATUS))
      throw "Could not link the shader program!";
   gl.useProgram(program);
   gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
   gl.enable(gl.DEPTH_TEST);
   gl.depthFunc(gl.LEQUAL);
   let vertexAttribute = (name, size, position) => {
      let attr = gl.getAttribLocation(program, name);
      gl.enableVertexAttribArray(attr);
      gl.vertexAttribPointer(attr, size, gl.FLOAT, false, vertexSize * 4, position * 4);
   }
   vertexAttribute('aPos', 3, 0);
   return gl;
}

// LOGIC TO TRACK THE CURSOR

let r = canvas1.getBoundingClientRect(), cursor = [0,0,0];
let setCursor = (e, z) => cursor = [ (e.clientX - r.left) / canvas1.width * 2 - 1,
                                     1 - (e.clientY - r.top) / canvas1.height * 2,
                                     z !== undefined ? z : cursor[2] ];
canvas1.onmousedown = e => setCursor(e, 1);
canvas1.onmousemove = e => setCursor(e,  );
canvas1.onmouseup   = e => setCursor(e, 0);

// TRIANGLE DATA (IN THIS CASE, ONE SQUARE)

let meshData = [
   { type: 1, mesh: new Float32Array([ -1,1,0, 1,1,0, -1,-1,0, 1,-1,0 ]) },
];

const NSPHERES = 3;  // Three spheres for this example
const NLIGHTS = 2;   // Two light sources

// VERTEX AND FRAGMENT SHADERS

let vertexSize = 3;
let vertexShader = `
   attribute vec3 aPos;
   varying   vec3 vPos;
   void main() {
      gl_Position = vec4(aPos, 1.0);
      vPos = aPos;
   }
`;

let fragmentShader = `
   precision mediump float;
   uniform float uTime, uFL;
   uniform vec3  uCursor;
   uniform vec4  uSpheres[`+NSPHERES+`]; // Array of spheres: (x,y,z,r)
   uniform vec4  uLights[`+NLIGHTS+`];   // Array of lights: (x,y,z,intensity)
   varying vec3  vPos;

   vec3 bgColor = vec3(0.,0.,.05);

   // Function to check ray-sphere intersection
   float raySphere(vec3 V, vec3 W, vec3 C, float r) {
      V -= C;
      float VV = dot(V,V);
      float VW = dot(V,W);
      float d = VW * VW - (VV - r*r);
      if (d > 0.) return -VW - sqrt(d);
      return -1.;
   }

   void main(void) {
      vec3 color = bgColor;   // Background color
      vec3 V = vec3(0.);      // Camera is at origin
      vec3 W = normalize(vec3(vPos.xy,-uFL));  // Ray direction

      vec3 material, highlight;
      float power;

      // Set materials based on cursor x position
      if (uCursor.x < -.3) {
         material = vec3(0.8, 0.5, 0.1);   // Gold
         highlight = vec3(1.0, 0.8, 0.5);
         power = 8.0;
      } else if (uCursor.x > .3) {
         material = vec3(0.7, 0.3, 0.3);   // Copper
         highlight = vec3(0.9, 0.5, 0.5);
         power = 6.0;
      } else {
         material = vec3(0.9, 0.2, 0.2);   // Red Plastic
         highlight = vec3(1.0);
         power = 20.0;
      }

      // Ray tracing for spheres
      float tMin = 1000.;
      for (int i = 0; i < ` + NSPHERES + `; i++) {
         vec3 C = uSpheres[i].xyz;   // Sphere center
         float r = uSpheres[i].w;    // Sphere radius
         float t = raySphere(V, W, C, r);  // Check for intersection
         if (t > 0. && t < tMin) {
            tMin = t;
            vec3 P = V + t * W;  // Intersection point
            vec3 N = normalize(P - C);  // Surface normal
            color = material * 0.3;

            // Lighting calculation for multiple lights
            for (int j = 0; j < ` + NLIGHTS + `; j++) {
               vec3 L = normalize(uLights[j].xyz - P);  // Direction to light
               float intensity = uLights[j].w;          // Light intensity
               vec3 d = material * max(0., dot(N,L)) * intensity;  // Diffuse lighting
               vec3 R = reflect(-L, N);  // Reflection direction
               vec3 s = highlight * pow(max(0., dot(R, W)), power);  // Specular highlight
               color += d + s;  // Add lighting
            }
         }
      }

      gl_FragColor = vec4(sqrt(color), 1.);
   }
`;

// WAIT 100 MSECS BEFORE STARTING UP

setTimeout(() => {
   let gl = start_gl(canvas1, meshData, vertexSize, vertexShader, fragmentShader);

   // FIND LOCATIONS IN GPU PROGRAM OF UNIFORM VARIABLES
   let uFL       = gl.getUniformLocation(gl.program, "uFL"      );
   let uTime     = gl.getUniformLocation(gl.program, "uTime"    );
   let uCursor   = gl.getUniformLocation(gl.program, "uCursor"  ); 
   let uSpheres  = gl.getUniformLocation(gl.program, "uSpheres" );
   let uLights   = gl.getUniformLocation(gl.program, "uLights"  );

   // ANIMATE AND RENDER EACH FRAME
   let startTime = Date.now() / 1000;
   setInterval(() => {
      // Update uniform variables
      let time = Date.now() / 1000 - startTime;
      gl.uniform1f(uTime, time);
      gl.uniform3fv(uCursor, cursor);
      gl.uniform1f(uFL, 3);

      // Sphere positions and radii
      let sphereData = [
         0.0,  0.3, -0.8, 0.15,   // Sphere 1 (centered)
         0.3, -0.2, -0.9, 0.12,   // Sphere 2
        -0.3, -0.3, -0.7, 0.2     // Sphere 3
      ];
      gl.uniform4fv(uSpheres, sphereData);

      // Light positions and intensities
      let lightData = [
         1.0, 1.0, 0.5, 1.5,    // Light 1 (bright)
        -1.0, 1.0, 0.5, 0.8     // Light 2 (dim)
      ];
      gl.uniform4fv(uLights, lightData);

      // Render the frame
      for (let n = 0 ; n < meshData.length ; n++) {
         let mesh = meshData[n].mesh;
         gl.bufferData(gl.ARRAY_BUFFER, mesh, gl.STATIC_DRAW);
         gl.drawArrays(meshData[n].type ? gl.TRIANGLE_STRIP : gl.TRIANGLES, 0, mesh.length / vertexSize);
      }
   }, 30);
}, 100);

</script>
</body>
